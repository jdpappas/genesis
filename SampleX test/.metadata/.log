!SESSION 2013-05-13 11:27:56.875 -----------------------------------------------
eclipse.buildId=M20120914-1800
java.version=1.7.0_21
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86

!ENTRY org.eclipse.e4.ui.workbench 4 0 2013-05-13 12:39:12.968
!MESSAGE 
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.core.commands.NotHandledException: There is no handler to execute for command org.eclipse.ui.edit.copy
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:229)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:210)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:131)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:171)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:276)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:494)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:545)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:366)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:313)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:82)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1100)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1521)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4640)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4528)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4989)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2546)
	at org.eclipse.swt.ole.win32.OleFrame.getMsgProc(OleFrame.java:279)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3129)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3753)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)
Caused by: org.eclipse.core.commands.NotHandledException: There is no handler to execute for command org.eclipse.ui.edit.copy
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:84)
	at sun.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)
	... 48 more

!ENTRY org.eclipse.e4.ui.workbench 4 0 2013-05-13 12:39:13.015
!MESSAGE 
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.core.commands.NotHandledException: There is no handler to execute for command org.eclipse.ui.edit.copy
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:229)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:210)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:131)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:171)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:276)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:494)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:545)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:366)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:313)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:82)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:774)
	at org.eclipse.swt.browser.WebBrowser.sendKeyEvent(WebBrowser.java:700)
	at org.eclipse.swt.browser.IE.handleDOMEvent(IE.java:1689)
	at org.eclipse.swt.browser.IE$5.handleEvent(IE.java:331)
	at org.eclipse.swt.ole.win32.OleEventTable.sendEvent(OleEventTable.java:55)
	at org.eclipse.swt.ole.win32.OleEventSink.notifyListener(OleEventSink.java:145)
	at org.eclipse.swt.ole.win32.OleEventSink.Invoke(OleEventSink.java:120)
	at org.eclipse.swt.ole.win32.OleEventSink.access$1(OleEventSink.java:97)
	at org.eclipse.swt.ole.win32.OleEventSink$1.method6(OleEventSink.java:71)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback6(COMObject.java:119)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2546)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3756)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)
Caused by: org.eclipse.core.commands.NotHandledException: There is no handler to execute for command org.eclipse.ui.edit.copy
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:84)
	at sun.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)
	... 49 more

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-13 15:27:14.843
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for JComponent [in JComponent.class [in javax.swing [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryField.getAttachedJavadoc(BinaryField.java:121)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:95)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:75)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:58)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:555)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-13 15:27:14.843
!MESSAGE Timed out while retrieving the attached javadoc for JComponent [in JComponent.class [in javax.swing [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-13 15:29:26.375
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for PrintStream [in PrintStream.class [in java.io [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:95)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:75)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:58)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:555)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-13 15:29:26.375
!MESSAGE Timed out while retrieving the attached javadoc for PrintStream [in PrintStream.class [in java.io [in C:\Program Files\Java\jre7\lib\rt.jar]]] 
!SESSION 2013-05-16 10:04:55.156 -----------------------------------------------
eclipse.buildId=M20120914-1800
java.version=1.7.0_21
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86

!ENTRY org.eclipse.e4.ui.workbench 4 0 2013-05-16 16:13:51.796
!MESSAGE 
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.core.commands.NotHandledException: There is no handler to execute for command org.eclipse.ui.edit.copy
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:229)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:210)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:131)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:171)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:276)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:494)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:545)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:366)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:313)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:82)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1100)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1521)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4640)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4528)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4989)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2546)
	at org.eclipse.swt.ole.win32.OleFrame.getMsgProc(OleFrame.java:279)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3129)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3753)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)
Caused by: org.eclipse.core.commands.NotHandledException: There is no handler to execute for command org.eclipse.ui.edit.copy
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:84)
	at sun.reflect.GeneratedMethodAccessor81.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)
	... 48 more

!ENTRY org.eclipse.e4.ui.workbench 4 0 2013-05-16 16:13:51.890
!MESSAGE 
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.core.commands.NotHandledException: There is no handler to execute for command org.eclipse.ui.edit.copy
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:229)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:210)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:131)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:171)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:276)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:494)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:545)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:366)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:313)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:82)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:774)
	at org.eclipse.swt.browser.WebBrowser.sendKeyEvent(WebBrowser.java:700)
	at org.eclipse.swt.browser.IE.handleDOMEvent(IE.java:1689)
	at org.eclipse.swt.browser.IE$5.handleEvent(IE.java:331)
	at org.eclipse.swt.ole.win32.OleEventTable.sendEvent(OleEventTable.java:55)
	at org.eclipse.swt.ole.win32.OleEventSink.notifyListener(OleEventSink.java:145)
	at org.eclipse.swt.ole.win32.OleEventSink.Invoke(OleEventSink.java:120)
	at org.eclipse.swt.ole.win32.OleEventSink.access$1(OleEventSink.java:97)
	at org.eclipse.swt.ole.win32.OleEventSink$1.method6(OleEventSink.java:71)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback6(COMObject.java:119)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2546)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3756)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)
Caused by: org.eclipse.core.commands.NotHandledException: There is no handler to execute for command org.eclipse.ui.edit.copy
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:84)
	at sun.reflect.GeneratedMethodAccessor81.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)
	... 49 more
!SESSION 2013-05-18 17:01:30.953 -----------------------------------------------
eclipse.buildId=M20120914-1800
java.version=1.7.0_21
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-18 18:44:51.203
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for ImageObserver [in ImageObserver.class [in java.awt.image [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryField.getAttachedJavadoc(BinaryField.java:121)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:95)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:75)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:58)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:555)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-18 18:44:51.203
!MESSAGE Timed out while retrieving the attached javadoc for ImageObserver [in ImageObserver.class [in java.awt.image [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-18 18:44:55.562
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for ImageObserver [in ImageObserver.class [in java.awt.image [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryField.getAttachedJavadoc(BinaryField.java:121)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:95)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:75)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:58)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:555)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-18 18:44:55.562
!MESSAGE Timed out while retrieving the attached javadoc for ImageObserver [in ImageObserver.class [in java.awt.image [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-18 18:45:10.359
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for ImageObserver [in ImageObserver.class [in java.awt.image [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryField.getAttachedJavadoc(BinaryField.java:121)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:95)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:75)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:58)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:555)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-18 18:45:10.359
!MESSAGE Timed out while retrieving the attached javadoc for ImageObserver [in ImageObserver.class [in java.awt.image [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-18 19:18:23.468
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for Graphics [in Graphics.class [in java.awt [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:95)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:75)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:58)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:555)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-18 19:18:23.468
!MESSAGE Timed out while retrieving the attached javadoc for Graphics [in Graphics.class [in java.awt [in C:\Program Files\Java\jre7\lib\rt.jar]]] 
!SESSION 2013-05-21 13:39:18.750 -----------------------------------------------
eclipse.buildId=M20120914-1800
java.version=1.7.0_21
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-21 15:37:52.359
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for AbstractAction {key=Ljavax/swing/AbstractAction;} [in AbstractAction.class [in javax.swing [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:995)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:619)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-21 15:37:52.375
!MESSAGE Timed out while retrieving the attached javadoc for AbstractAction {key=Ljavax/swing/AbstractAction;} [in AbstractAction.class [in javax.swing [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-21 15:44:17.828
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for MouseEvent [in MouseEvent.class [in java.awt.event [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:95)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:75)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:58)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:555)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-21 15:44:17.828
!MESSAGE Timed out while retrieving the attached javadoc for MouseEvent [in MouseEvent.class [in java.awt.event [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.ui 4 10001 2013-05-21 15:49:52.015
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for RectangularShape [in RectangularShape.class [in java.awt.geom [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:463)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:95)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:75)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:58)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:555)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2013-05-21 15:49:52.015
!MESSAGE Timed out while retrieving the attached javadoc for RectangularShape [in RectangularShape.class [in java.awt.geom [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.core 4 4 2013-05-21 19:01:46.343
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));

		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		
		public void mousePressed(MouseEvent e) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							System.out.println(exP.tag);
							
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					System.out.println(part.tag);
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			this.move();
		} // close move method
		
		public void move() {
			new Thread {
				public void run
			System.out.println(selPart.tag);
			if (selPart.tag.charAt(0)=='Z'){
				HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				int a=1;
				if (base.p.y > selPart.p.y ) {
					a=-1;
				} // end if
				
				while (base.p.y != selPart.p.y) {
				
				repaint();
				base.p.y=base.p.y+a;
				try {Thread.sleep(20); }
				catch (Exception ex) {}
				} // close loop
				
			} else if (selPart.tag.charAt(0)=='h') {
				// head plunger, puller, magnet
			} else if (selPart.tag.charAt(0)=='r'){
				// robot motion
			} // close if
			}.run();
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:2877)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:380)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:176)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-21 19:01:46.343
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:2877)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:380)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:176)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-21 19:01:46.343
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:2877)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:380)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:176)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-21 19:01:46.656
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));

		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		
		public void mousePressed(MouseEvent e) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							System.out.println(exP.tag);
							
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					System.out.println(part.tag);
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			this.move();
		} // close move method
		
		public void move() {
			new Thread {
				public void run
			System.out.println(selPart.tag);
			if (selPart.tag.charAt(0)=='Z'){
				HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				int a=1;
				if (base.p.y > selPart.p.y ) {
					a=-1;
				} // end if
				
				while (base.p.y != selPart.p.y) {
				
				repaint();
				base.p.y=base.p.y+a;
				try {Thread.sleep(20); }
				catch (Exception ex) {}
				} // close loop
				
			} else if (selPart.tag.charAt(0)=='h') {
				// head plunger, puller, magnet
			} else if (selPart.tag.charAt(0)=='r'){
				// robot motion
			} // close if
			}.run();
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:2877)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:380)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:176)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-21 19:01:46.656
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:2877)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:380)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:176)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-21 19:01:46.671
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:2877)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:380)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:176)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SESSION 2013-05-22 09:46:07.328 -----------------------------------------------
eclipse.buildId=M20120914-1800
java.version=1.7.0_21
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.046
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.234
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.234
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.312
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.312
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.375
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.375
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.375
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.421
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.421
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.437
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.484
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.484
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.484
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.546
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.546
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.546
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.609
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.609
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.609
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.687
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.687
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.687
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.750
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.750
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.750
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.796
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.796
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.812
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.859
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.859
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.859
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:12:53.906
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:12:53.921
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:12:53.921
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:03.859
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:03.875
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:03.875
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:03.953
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:03.953
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:03.953
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:04.015
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:04.015
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:04.015
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:04.078
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:04.078
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:04.078
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:04.140
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:04.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:04.140
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:04.203
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:04.203
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:04.203
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:04.250
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:04.265
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:04.265
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:04.312
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:04.312
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:04.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:04.359
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:04.375
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:04.375
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:04.421
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:04.421
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:04.421
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:09.375
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)

!ENTRY org.eclipse.jdt.ui 4 2 2013-05-22 13:13:09.375
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)

!ENTRY org.eclipse.jdt.ui 4 0 2013-05-22 13:13:09.375
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)

!ENTRY org.eclipse.jdt.core 4 4 2013-05-22 13:13:09.453
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package testBob;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;


public class Case1 extends JComponent {
	// The dimensions of the application's window.
	private static final int winWidth=800;
	private static final int winHeight=600;
	// The standard sensor dimension
	int senDim = 10;
	// The list of all the object-parts that compose the machine.
	private static List<MechPart> mechparts = new ArrayList<MechPart>();
		
	public static void main(String[] args) {
		// invokeLater takes a Runnable object and queues it to be processed by EventDispatcher Thread.
		// The run method will be called after all queued events are processed.
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				// creates a new frame named testMech
				JFrame f = new JFrame("TestMech");
				// defines the close operation
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				// an instance of Case1 is created
				Case1 application = new Case1();
				// sets the size of the application window
				// setPreferredSize is preferred over setSize when a LayoutManager is used
				application.setPreferredSize(new Dimension(winWidth,winHeight));
				
				// Adds the pane where the components will be drawn to the frame
				f.add(new JScrollPane(application),BorderLayout.CENTER);
				// Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
				f.pack();
				// creates the parts of the machine
				application.createParts();
				// tells that the location where the window will appear will be determined by the OS
				f.setLocationByPlatform(true);
				// make the frame visible
				f.setVisible(true);
			} // close run method
		}); // close Runnable

	} // close main method
	
	public Case1() {
		this.setOpaque(true);
		this.addMouseListener(new MouseHandler());
		 
	} // close Case1 constructor method
	
	public void createParts() {
		// get the window dimensions to specify the parts' position
		int winW=winWidth;
		int winH=winHeight;
		// Carrier Lock Sensor -----------------------------------------
		mechparts.add(new Sensor(new String("CL"),new Point(winW-senDim,winH-senDim),
					  new Dimension(senDim,senDim),new Color(228,114,27)));
		// Carrier Start Sensors ---------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("SC "+(i+1)), new Point(winW-senDim,215+50*i),
					      new Dimension(senDim,senDim),new Color(30,137,208)));
		} // close loop
		// Carrier End Sensors ------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new Sensor(new String("EC "+(i+1)), new Point(100,215+50*i),
						  new Dimension(senDim,senDim),new Color(92,79,172)));
		} // close loop
		// Z Motion Sensors ---------------------------------------------
		mechparts.add(new Sensor(new String("ZT"), new Point(20,0),
					  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		for (int i=1; i<6; i++) {
			mechparts.add(new Sensor(new String("ZT "+(i)), new Point(20,50+50*i),
						  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		} // close loop
		mechparts.add(new Sensor(new String("ZB"), new Point(20,400),
				  new Dimension(2*senDim,senDim),new Color(75,148,89)));
		// Carriers -----------------------------------------------------
		for (int i=0; i<5; i++) {
			mechparts.add(new PlateCarrier(new String("Carrier "+(i+1)), new Point(610,215+50*i),
					      new Dimension(180,10),new Color(0,100,150)));
		} // close loop
		// Head  --------------------------------------------------------
		// actually all the parts that are moved through the head motion (head sensors and robot)
		// are create inside the head base object
		mechparts.add(new HeadBase(new String("Head "), new Point(110,0), new Dimension(180,10), new Color(133,144,246)));
	} // close createParts method
	
	public void paintComponent(Graphics g) { // inherited from JComponent
		// repaints the window in order to delete what has been painted before
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
		// paints the green rectangle on the left of the panel
		g.setColor(new Color(75,148,89));
		g.fillRect(0, 0, 20, 600);
		
		// draws all the parts of the machine
		for (MechPart m : mechparts) {
			m.draw(g);
		} // close loop
		
	} // close paintComponent method
	
	
	// MechPart is defined as abstract and it must be subclassed
	private abstract class MechPart {
		String tag;
		Point p; // the upper left corner of the object
		Dimension d; // the width and height
		Color color; // the color of the object
		boolean selected=false;
		MechPart[] extraParts; // an array to hold the sub-objects of the part (e.g. sensors)
		Rectangle b = new Rectangle(); // the rectangle is used to define the area of the object
		
		public MechPart(String tag, Point p, Dimension d, Color color) {
			this.tag=tag; // the parts name
			this.p=p; // the parts upper left corner coordinates
			this.d=d; // the parts width and height
			this.color=color;
			setBoundary(b);
		} // close MechPart constructor method
		
		public void setBoundary(Rectangle b){
			b.setBounds(p.x,p.y,d.width,d.height);
		} // close setBoundary method
		
		// the draw method will be overridden from the subclasses
		public void draw(Graphics g) {
			g.setColor(this.color);
		} // close draw method
		
	} // close MechPart class
	
	
	private class Sensor extends MechPart {
		
		public Sensor(String tag,Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		
		} // close Sensor constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
		
	} // close Sensor class
	
	
	private class PlateCarrier extends MechPart {
		
		public PlateCarrier(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close PlateCarrier constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y; int dimX=d.width; int dimY=d.height;
			g.fillRect(posX,posY,dimX/2-15,dimY);
			g.fillRect(posX+dimX/2+15,posY,dimX/2-15,dimY);
			g.drawLine(posX+dimX/2-15,posY,posX+dimX/2+15,posY);
			// observe the -1 in the y-position definition
			g.drawLine(posX+dimX/2-15,posY-1+dimY,posX+dimX/2+15,posY+dimY-1);
		} // close draw method
	} // close PlateCarrier class
	
	
	private class Robot extends MechPart {
		
		public Robot(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the robot carries 4 sensors which are place in the extraParts array
			Color senColor = new Color(172,36,81);
			Point[] senPoints = new Point[4]; // the array that holds the coordinates of the sensors
			extraParts = new MechPart[4]; // the array has to be instantiated before the variables are assigned!!
			senPoints[0]=new Point(p.x+10,p.y);
			senPoints[1]=new Point(p.x+10,p.y+20);
			senPoints[2]=new Point(p.x	 ,p.y+10);
			senPoints[3]=new Point(p.x+20,p.y+10);
			// The sensors are created here (inside robot object and assigned to extraParts array)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i]=new Sensor(new String("R "+(i+1)), senPoints[i], new Dimension(senDim,senDim), senColor);
			} // close loop
			
		} // close Robot constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// drawRect is different from fillRect
			g.drawRect(p.x,p.y,d.width,d.height);
			// we draw the extra parts of the robot (here the sensors)
			for (int i=0;i<extraParts.length;i++) {
			extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close Robot class
	
	
	private class HeadPuller extends MechPart {
		
		int offset;
		
		public HeadPuller(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			// the HeadPuller has only one sensor
			extraParts = new MechPart[1];
			extraParts[0]=new Sensor(new String("HPD"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadPuller constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[6];
			int[] yPos = new int[6];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+20; xPos[4]=posX+20; xPos[5]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+10; yPos[3]=posY+10; yPos[4]=posY+5; yPos[5]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensor)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadPuller class
	
	private class HeadPlunger extends MechPart {
		
		int offset=15;
		
		public HeadPlunger(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
		} // close HeadPlunger constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			g.fillRect(p.x,p.y,d.width,d.height);
		} // close draw method
	} // close HeadPlunger class
	
	
	private class HeadMagnet extends MechPart {
		
		int offset=105-;
		public HeadMagnet(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// HeadMagnet has 2 sensors on it
			extraParts = new MechPart[2];
			extraParts[0]=new Sensor(new String("HPU"), new Point(p.x+160,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[1]=new Sensor(new String("HPM"), new Point(p.x,p.y+5), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
			
		} // close HeadMagnet constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			// the following point-arrays are required to draw a polygon shaped object
			int posX=p.x; int posY=p.y;
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+180; xPos[2]=posX+180; xPos[3]=posX+160; xPos[4]=posX+160; xPos[5]=posX+20;
			xPos[6]=posX+20; xPos[7]=posX; 
			yPos[0]=posY; yPos[1]=posY; yPos[2]=posY+5; yPos[3]=posY+5; yPos[4]=posY+10; yPos[5]=posY+10; 
			yPos[6]=posY+5; yPos[7]=posY+5; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// the extra parts are drawn (sensors)
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
			} // close loop
		} // close draw method
		
	} // close HeadMagnet class
	
	private class HeadBase extends MechPart {
		
		public HeadBase(String tag, Point p, Dimension d, Color color) {
			super(tag, p, d, color); // calls the constructor of the super class
			
			// The HeadBase contains the HeadPuller, HeadPlunger and HeadMagnet
			// also the HPD and HPU sensors
			// finally the Robot and the start and end robot sensors
			extraParts = new MechPart[8];
			extraParts[0]=new HeadPuller(new String("hpuller"), new Point(p.x,p.y+55), new Dimension(180,10), new Color(100,116,255));
			extraParts[1]=new HeadPlunger(new String("hplungers"), new Point(p.x,p.y+10), new Dimension(180,10), new Color(100,116,255));
			extraParts[2]=new HeadMagnet(new String("hmagnet"), new Point(p.x,p.y+105), new Dimension(180,10), new Color(56,76,252));
			extraParts[3]=new Robot(new String("robot"), new Point(p.x+575,p.y+105-1), new Dimension(30,30), new Color(172,36,81));
			extraParts[4]=new Sensor(new String("RE"), new Point(p.x+65,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[5]=new Sensor(new String("RS"), new Point(p.x+605,p.y+125), new Dimension(senDim,senDim), new Color(172,36,81));
			extraParts[6]=new Sensor(new String("HMD"), new Point(p.x,p.y+35), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			extraParts[7]=new Sensor(new String("HMP"), new Point(p.x+160,p.y+50), new Dimension(2*senDim,senDim-5), new Color(24,45,181));
			
		} // close HeadBase constructor method
		
		@Override
		public void draw(Graphics g) {
			// calls the draw method of the superclass, else it would only call the commands specified in the subclass
			super.draw(g); 
			int posX=p.x; int posY=p.y;
			g.fillRect(posX, posY, d.width, d.height); // the upper part of the head (above the plungers)
			g.setColor(extraParts[4].color); 
			// the line where the robot moves
			// extraParts 4 and 5 are the start and end sensors of the robot
			g.drawLine(extraParts[4].p.x+10, extraParts[4].p.y+10-1, extraParts[5].p.x, extraParts[5].p.y+10-1);
			g.setColor(this.color);
			// the coordinates for the creation of the polygon - static part of the HeadBase
			int[] xPos = new int[8];
			int[] yPos = new int[8];
			xPos[0]=posX; xPos[1]=posX+20; xPos[2]=posX+20; xPos[3]=posX+180; xPos[4]=posX+180; xPos[5]=posX+160;
			xPos[6]=posX+160; xPos[7]=posX; 
			yPos[0]=posY+40; yPos[1]=posY+40; yPos[2]=posY+35; yPos[3]=posY+35; yPos[4]=posY+50; yPos[5]=posY+50; 
			yPos[6]=posY+55; yPos[7]=posY+55; 
			g.fillPolygon(xPos,yPos,xPos.length);
			// Draws the HeadPuller-Plunger-Magnet, Robot, Head and Robot Sensors
			for (int i=0;i<extraParts.length;i++) {
				extraParts[i].draw(g);	
				} // close loop
		} // close draw method
		
	} // close HeadBase class
	
	public class MouseHandler extends MouseAdapter {
		int oldThread=Thread.activeCount();
		int newThread;
		
		public void mousePressed(MouseEvent e) {
			newThread=Thread.activeCount();

			if (oldThread==newThread) {
			Motion motion = new Motion();
			motion.setSelected(e.getPoint());
			} // close if
		} // close mousePressed method
		
	} // close MouseHandler class
	
	public class Motion {
		MechPart selPart;
		final int speed=2;
		
		public void setSelected (Point chosenP) {
			for (MechPart part : mechparts) {
							
				if (part.extraParts != null) {
					for (MechPart exP:part.extraParts) {
						if (exP.b.contains(chosenP)) {
							exP.selected=true;
							selPart=exP;
							continue;			
						} // close if
					} // close loop
				} // close if
				
				if (part.b.contains(chosenP)) {
					part.selected=true;
					selPart=part;
					continue;
				} // close if	
				
			} // close loop
			if (selPart != null){
				this.move();
			} // close if
			
		} // close setSelected method
		
		
		public void move() {
			
			if (selPart.tag.charAt(0)=='Z'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
					
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='h') {

				final HeadBase h=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
				
			} else if (selPart.tag.charAt(0)=='r'){
				final HeadBase base=(HeadBase) mechparts.get(mechparts.size()-1);
				
				new Thread() {
					public void run() {
						
				while (base.p.y != selPart.p.y) {
					
					
					if (base.p.y > selPart.p.y ) {
						base.p.y=base.p.y-speed;
					} else if (base.p.y < selPart.p.y ) {
						base.p.y=base.p.y+speed;
					} // end if
					
				repaint();
				try {Thread.sleep(20);}
				catch (Exception ex) {}
				} // close loop
					} // close run
				}.start(); // close Thread
			} // close if
			
			
		} // close move method
		
	} // close Motion class
	
} // close Case1 class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.text.correction.ASTResolving.createQuickFixAST(ASTResolving.java:1132)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)

!ENTRY org.eclipse.ui 4 0 2013-05-22 13:13:09.453
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.IllegalArgumentException)
	at org.eclipse.swt.SWT.error(SWT.java:4361)
	at org.eclipse.swt.SWT.error(SWT.java:4276)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:138)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4144)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1029)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:923)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:86)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1438)
Caused by: java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:503)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.text.correction.ASTResolving.createQuickFixAST(ASTResolving.java:1132)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	... 23 more
